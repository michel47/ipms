
ò)ê)#!/bin/sh

# this script publish the hash of /.brings to the peerid

set -e

yellow="[33m"
red="[31m"
nc="[0m"

tic=$(date +%s)
script=$0
script_basename=`basename $script`

debug=0
verbose=0
trace=0
if [ `echo $* |grep -c debug` -eq 1 ];then debug=1;fi
if [ `echo $* |grep -c verbose` -eq 1 ];then verbose=1;fi
if [ `echo $* |grep -c trace` -eq 1 ];then trace=1;fi

# set up local IPFS environment ...
export IPFS_PATH=$(pwd)/_ipfs
export PATH=_ipfs/bin:$(pwd)/bin:$PATH
#export LC_TIME='fr_FR.UTF-8'

add_dotbrings_directory_of_file()
{
    fullpath=$1
    dir=`dirname $fullpath`
    if [ "$dir" = "." ]
    then
	fullpath="/.brings/"${fullpath}
    fi
    echo $fullpath
}

check_exist_brings()
{
    if ! ipfs files stat --hash /.brings 1>/dev/null 2>&1; then
	ipfs files mkdir -p /.brings
    fi
}

check_ipfs_running()
{
    if [ `ps aux | grep -c ipfs` -le 1 ]
    then
	echo " ${yellow}WARNING no ipfs daemon running${nc}"
	echo " ${yellow}WARNING running start.sh${nc}"
	start.sh
    fi
}

check_perl_local_lib()
{
    if ! perl -Mlocal::lib=$(pwd)/_perl5 -e 1; then
	echo " WARNING perl: local::lib not found"
	echo " running . rc.sh"
	. rc.sh
    fi
}

copy_to_my_friends_of_hash_of_who()
{
    if [ $# -ne 2 ]
    then
	echo "Input parameters : $*"
	echo "ERROR"
	echo "Usage: copy_to_my_friends_of_hash_of_who <hash> <who>"
	exit
    fi

    hash=$1
    who=$2
    
    if [ $debug -eq 1 ]; then
       echo "Entering in copy_to_my_friends_of_hash_of_who $*"
    fi
       
    if ! ipfs files stat --hash /my/friends 1>/dev/null 2>&1; then
	ipfs files mkdir -p /my/friends
    fi
    ipfs files cp /ipns/${hash} /my/friends/${who}

}

ipfs_append_of_file()
{
    fullpath=`add_dotbrings_directory_of_file $1`
    file=`basename $1`

    echo "ipfs_append_of_file : fullpath $fullpath"
    echo "ipfs_append_of_file : file $file append"
    
    ipfs files read "${fullpath}" > /tmp/${file}
    echo "$tic: $qm" >> /tmp/${file}
    ipfs files write --create  --truncate "${fullpath}" < /tmp/${file}
    rm -f /tmp/${file}
}

publish_of_hashable_of_log_directory_of_action()
{
    hash_directory=$1
    log_directory=$2
    action=$3

    if [ $debug -eq 1 ]; then
       echo "Entering in publish_of_hashable_of_log_directory_of_action $*"
    fi
       
    if [ $# -ne 3 ]
    then
	echo "Input parameters : $*"
	echo "ERROR"
	echo "Usage: $script <hashable> <directory> <action>"
	exit
    fi
    qm=$(ipfs files stat --hash ${hash_directory})

    fullpath=`add_dotbrings_directory_of_file ${log_directory}`
    logfile=$fullpath".log"

    if sz=$(ipfs files stat --format="<size>" ${logfile} 2>/dev/null)
    then
	ipfs_append_of_file ${logfile}
    else
	echo "$tic: $qm" | ipfs files write --create $action "${logfile}"
    fi
}

publish_brings()
{
    if [ $debug -eq 1 ]; then
	echo "Entering in publish_brings $*"
    fi
    
    bot=$(ipfs add -Q $script)
    if ipfs files rm /.brings/${script_basename} 2>/dev/null; then true; fi
    ipfs files cp /ipfs/$bot "/.brings/${0##*/}"

    brkey=$(ipfs files stat --hash /.brings)
    echo "brkey: $brkey"
    #ipfs files read /.brings/brings.log
    #ipfs files read /.brings/brings.log | wc
    #ipfs files stat /.brings/brings.log
    echo .

    if ipfs files stat --hash /.brings/brings.log 1>/dev/null 2>&1 ; then
	sz=$(ipfs files stat --format="<size>" /.brings/brings.log 2>/dev/null)

	ipfs_append_of_file brings.log
    else
	echo "$tic: $brkey" | ipfs files write --create --raw-leaves "/.brings/brings.log"
    fi
}

publish_root()
{
    if [ $debug -eq 1 ]; then
	echo "Entering in publish_root $*"
    fi
    
    if [ "x$email" = 'x' ]
    then
	echo "ERROR email variable is not set!"
	exit
    fi
    
    if ! ipfs files stat --hash /root/directory 1>/dev/null 2>&1; then
	ipfs files mkdir /root/directory
    else
	if ipfs files rm -r "/root/directory/$email" 2>/dev/null; then true; fi
    fi

    qm=$(ipfs files stat --hash /my/identity)
    ipfs files cp /ipfs/$qm "/root/directory/$email"
}

if [ "x$1" = 'x-off' ]; then shift; offline='--offline'; fi

check_perl_local_lib;
check_ipfs_running;

gwhost=$(ipfs config Addresses.Gateway | cut -d'/' -f 3)
gwport=$(ipfs config Addresses.Gateway | cut -d'/' -f 5)
peerid=$(ipfs config Identity.PeerID)
eval "$(fullname -a $peerid | eyml)"

check_exist_brings;

publish_of_hashable_of_log_directory_of_action /my/identity/public.yml identity --raw-leaves;
publish_of_hashable_of_log_directory_of_action /public public '';

publish_root;

publish_of_hashable_of_log_directory_of_action /root root '';
publish_of_hashable_of_log_directory_of_action /my my --truncate;

publish_brings;

#ipfs files read "/.brings/brings.log"
ipfs files stat /.brings/brings.log
echo .
brkey=$(ipfs files stat --hash /.brings)
ipfs --offline name publish --allow-offline $brkey 1>/dev/null 2>&1
echo "url: https://gateway.ipfs.io/ipfs/$brkey"
echo "url: http://$gwhost:$gwport/ipns/$peerid"

ipfs $offline name publish --allow-offline $brkey | sed -e 's/^/info: /';

copy_to_my_friends_of_hash_of_who QmaCKrPUFzXjnCAxdL6af2TkSAEj9sneZXGH9gwZR3tvfY alaina;

copy_to_my_friends_of_hash_of_who QmZV2jsMziXwrsZx5fJ6LFXDLCSyP7oUdfjXdHSLbLXxKJ michelc; 

copy_to_my_friends_of_hash_of_who QmVmTsmUVuphtck8AWsz4fhUwxy7187SzEPMbapcH52gvb emilea;


ê)