
Æ¾#!/usr/bin/perl

$| = 1;
use Crypt::Digest::SHAKE;

my $l = 19;
my $resultf='wcode';
my $vanity='M4GC\d+$';

my $pat;
   $pat='^.{5}\d*PoW\d+';
my $patf='?PoW[0-9]';
printf "pattern: %s\n",$pat;

my $tmpl = <<'EOT';
## Proof of Good Intent ...

This is a proof of concept for pow-addressable-content (hash length=%len%)

if a bad actor try to hack the system something will be off with this file
(i.e. signed peerid might be wrong etc.)

with k=%k% (elapsed: %elapsed%s)

file stored w/ command:
ipfs add --raw-leaves --hash shake-256 %filep% --cid-base base58btc

previous collision: [%k%](https://gateway.ipfs.io/ipfs/%prevhash%)

---
col: %col%
pattern: %pat%
pcode: %pcode%
...
$code: %code%$
EOT

my $k = 0;
my $buf0 = $tmpl; # genesis block ...
   $buf0 =~ s/%prevhash%/z*%patf%/g;
   $buf0 =~ s/%len%/$l/g;
   $buf0 =~ s/%code%/~/g;
   $buf0 =~ s/%k%/$k/g;
   $buf0 =~ s/%elapsed%/0/;
   $buf0 =~ s/%col%/0/g;
   $buf0 =~ s/%pcode%/~/g;
   $buf0 =~ s/%pat%/$pat/g;
   $buf0 =~ s/%filep%/$resultf$k-z*.txt/g;
my $hash = shake($l,$buf0);
my $mh58 = &encode_base58("\x01\x55\x19".chr($l).$hash);
my $file = sprintf'%s%d-z%s.txt',$resultf,$k,$mh58;
open F,'>',$file; print F $buf0; close F;

my $filep = sprintf'%s%d-z*%s*.txt',$resultf,$k,$patf;
my $buf0 = $tmpl; # first block
   $buf0 =~ s/%prevhash%/z$mh58/g;
   $buf0 =~ s/%len%/$l/g;
   $buf0 =~ s/%col%/1/g;
   $buf0 =~ s/%pcode%/~/g;
   $buf0 =~ s/%pat%/$pat/g;
   $buf0 =~ s/%filep%/$filep/g;
my $col = 1;
my $pcode = '~';
my $next = 60;
while (1) {
  my $code = &base62($k);
  $buf = $buf0;
  $buf =~ s/%code%/$code/;
  $buf =~ s/%k%/$k/g;
  $elapsed = time() - $^T;
  $buf =~ s/%elapsed%/$elapsed/;
  my $hash = shake($l,$buf);
  my $mh58 = &encode_base58("\x01\x55\x19".chr($l).$hash);
  if ($mh58 =~ m/$pat/) {
	 printf "%.2f: k: %u, code: %s -> hash: %s, mh58: z%s *\n",$elapsed/60,$k,$code,unpack('H*',$hash),$mh58;
         my $file = sprintf'%s%d-z%s.txt',$resultf,$k,$mh58;
	 open F,'>',$file; print F $buf; close F;
         system("ipfs add --raw-leaves --hash shake-256 $file --cid-base base58btc");
	 $col++;
	 $l++;
	 #$pat = substr($vanity,0,$l) if $l > 20;
	 #$patf = $pat; $patf =~ s/\\d/\[0-9]/g;
	 printf "pat: %s # l=%u\n",$pat,$l;
	 exit if $l > 32;
         my $filep = sprintf'%s%d-z*%s*.txt',$resultf,$k,$patf;
	 $buf0 = $tmpl;
         $buf0 =~ s/%col%/$col/g;
         $buf0 =~ s/%pat%/$pat/g;
         $buf0 =~ s/%filep%/$filep/g;
         $buf0 =~ s/%pcode%/$pcode/g;
         $buf0 =~ s/%prevhash%/z$mh58/g;
         $buf0 =~ s/%len%/$l/g;
	 $pcode = $code;
  } elsif ($elapsed > $next) {
	 $next += 10;
	 printf "%.2f: k: %8u, code: %s -> hash: %s, mh58: z%s\n",$elapsed/60,$k,$code,unpack('H*',$hash),$mh58;
  }
  $k++;
}
exit $?;

sub shake {
  my $len = shift;
  my $msg = Crypt::Digest::SHAKE->new(256);
     $msg->add(join'',@_);
  my $digest = $msg->done($len);
  return $digest; 
}

sub base62 { # 2x26 letters + 10 digits
  use integer;
  my ($n) = @_;
  my $e = '';
  #return('0') if $n == 0;
  while ( $n ) {
    my $c = $n % 62;
    $e .=  chr(0x30 + $c); # 0x30: 0 included
    $n = int $n / 62;
  }
  $e =~ y,0-m,A-Za-z0-9,;
  #return scalar reverse $e;
  return $e;
}
sub ubase62 {
  use integer;
  my ($s) = @_;
  $s =~ y,A-Za-z0-9,0-m,;
  my $n = 0;
  while ($s ne '') {
    my $c = substr($s,0,1,'');
    my $v = ord($c) - 0x30;
    $n *= 62; $n += $v;
  }
  return $n;
}
sub encode_base58 {
  use Math::BigInt;
  use Encode::Base58::BigInt qw();
  my $bin = join'',@_;
  my $bint = Math::BigInt->from_bytes($bin);
  my $h58 = Encode::Base58::BigInt::encode_base58($bint);
  $h58 =~ tr/a-km-zA-HJ-NP-Z/A-HJ-NP-Za-km-z/;
  return $h58;
}
¾